using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.ComponentModel;
using System.Globalization;
using System.IO;
using System.Linq;
using System.Runtime.InteropServices;
using System.Security;
using System.Text;
using System.Text.RegularExpressions;
using System.Threading;
using System.Xml.Linq;
using System.Xml.XPath;
using Microsoft.Win32.SafeHandles;
namespace WIM2VHD {
    public class
    NativeMethods {
        #region Delegates and Callbacks
        #region WIMGAPI
        public delegate uint
        WimMessageCallback(
            uint   MessageId,
            IntPtr wParam,
            IntPtr lParam,
            IntPtr UserData
        );
        public static void
        RegisterMessageCallback(
            WimFileHandle hWim,
            WimMessageCallback callback) {
            uint _callback = NativeMethods.WimRegisterMessageCallback(hWim, callback, IntPtr.Zero);
            int rc = Marshal.GetLastWin32Error();
            if (0 != rc) {
                throw
                    new InvalidOperationException(
                        string.Format(
                            CultureInfo.CurrentCulture,
                            "Unable to register message callback."
                ));
            }
        }
        public static void
        UnregisterMessageCallback(
            WimFileHandle hWim,
            WimMessageCallback registeredCallback) {
            bool status = NativeMethods.WimUnregisterMessageCallback(hWim, registeredCallback);
            int rc = Marshal.GetLastWin32Error();
            if (!status) {
                throw
                    new InvalidOperationException(
                        string.Format(
                            CultureInfo.CurrentCulture,
                            "Unable to unregister message callback."
                ));
            }
        }
        #endregion WIMGAPI
        #endregion Delegates and Callbacks
        #region Constants
        #region VDiskInterop
        public   const uint  OPEN_VIRTUAL_DISK_RW_DEFAULT_DEPTH   = 0x00000001;
        public   const uint  DEFAULT_BLOCK_SIZE                   = 0x00080000;
        public   const uint  DISK_SECTOR_SIZE                     = 0x00000200;
        internal const uint  ERROR_VIRTDISK_NOT_VIRTUAL_DISK      = 0xC03A0015;
        internal const uint  ERROR_NOT_FOUND                      = 0x00000490;
        internal const uint  ERROR_IO_PENDING                     = 0x000003E5;
        internal const uint  ERROR_INSUFFICIENT_BUFFER            = 0x0000007A;
        internal const uint  ERROR_ERROR_DEV_NOT_EXIST            = 0x00000037;
        internal const uint  ERROR_BAD_COMMAND                    = 0x00000016;
        internal const uint  ERROR_SUCCESS                        = 0x00000000;
        public   const uint  GENERIC_READ                         = 0x80000000;
        public   const uint  GENERIC_WRITE                        = 0x40000000;
        public   const short FILE_ATTRIBUTE_NORMAL                = 0x00000080;
        public   const uint  CREATE_NEW                           = 0x00000001;
        public   const uint  CREATE_ALWAYS                        = 0x00000002;
        public   const uint  OPEN_EXISTING                        = 0x00000003;
        public   const short INVALID_HANDLE_VALUE                 = -1;
        internal static Guid VirtualStorageTypeVendorUnknown      = new Guid("00000000-0000-0000-0000-000000000000");
        internal static Guid VirtualStorageTypeVendorMicrosoft    = new Guid("EC984AEC-A0F9-47e9-901F-71415A66345B");
        #endregion VDiskInterop
        #region WIMGAPI
        public   const uint  WIM_FLAG_VERIFY                      = 0x00000002;
        public   const uint  WIM_FLAG_INDEX                       = 0x00000004;
        public   const uint  WM_APP                               = 0x00008000;
        #endregion WIMGAPI
        #endregion Constants
        #region Enums and Flags
        #region VDiskInterop
        public enum CreateVirtualDiskVersion : int {
            VersionUnspecified         = 0x00000000,
            Version1                   = 0x00000001,
            Version2                   = 0x00000002
        }
        public enum OpenVirtualDiskVersion : int {
            VersionUnspecified         = 0x00000000,
            Version1                   = 0x00000001,
            Version2                   = 0x00000002
        }
        public enum AttachVirtualDiskVersion : int {
            VersionUnspecified         = 0x00000000,
            Version1                   = 0x00000001,
            Version2                   = 0x00000002
        }
        public enum CompactVirtualDiskVersion : int {
            VersionUnspecified         = 0x00000000,
            Version1                   = 0x00000001
        }
        public enum VirtualStorageDeviceType : int {
            Unknown                    = 0x00000000,
            ISO                        = 0x00000001,
            VHD                        = 0x00000002,
            VHDX                       = 0x00000003
        }
        [Flags]
        public enum OpenVirtualDiskFlags {
            None                       = 0x00000000,
            NoParents                  = 0x00000001,
            BlankFile                  = 0x00000002,
            BootDrive                  = 0x00000004,
        }
        [Flags]
        public enum VirtualDiskAccessMask {
            None                       = 0x00000000,
            AttachReadOnly             = 0x00010000,
            AttachReadWrite            = 0x00020000,
            Detach                     = 0x00040000,
            GetInfo                    = 0x00080000,
            Create                     = 0x00100000,
            MetaOperations             = 0x00200000,
            Read                       = 0x000D0000,
            All                        = 0x003F0000,
            Writable                   = 0x00320000
        }
        [Flags]
        public enum CreateVirtualDiskFlags {
            None                       = 0x00000000,
            FullPhysicalAllocation     = 0x00000001
        }
        [Flags]
        public enum AttachVirtualDiskFlags {
            None                       = 0x00000000,
            ReadOnly                   = 0x00000001,
            NoDriveLetter              = 0x00000002,
            PermanentLifetime          = 0x00000004,
            NoLocalHost                = 0x00000008
        }
        [Flags]
        public enum DetachVirtualDiskFlag {
            None                       = 0x00000000
        }
        [Flags]
        public enum CompactVirtualDiskFlags {
            None                       = 0x00000000,
            NoZeroScan                 = 0x00000001,
            NoBlockMoves               = 0x00000002
        }
        #endregion VDiskInterop
        #region WIMGAPI
        [FlagsAttribute]
        internal enum
        WimCreateFileDesiredAccess
            : uint {
            WimQuery                   = 0x00000000,
            WimGenericRead             = 0x80000000
        }
        [FlagsAttribute]
        internal enum
        WimApplyFlags
            : uint {
            WimApplyFlagsNone          = 0x00000000,
            WimApplyFlagsReserved      = 0x00000001,
            WimApplyFlagsVerify        = 0x00000002,
            WimApplyFlagsIndex         = 0x00000004,
            WimApplyFlagsNoApply       = 0x00000008,
            WimApplyFlagsNoDirAcl      = 0x00000010,
            WimApplyFlagsNoFileAcl     = 0x00000020,
            WimApplyFlagsShareWrite    = 0x00000040,
            WimApplyFlagsFileInfo      = 0x00000080,
            WimApplyFlagsNoRpFix       = 0x00000100,
            WimApplyFlagsMountReadOnly = 0x00000200,
            WimApplyFlagsMountFast     = 0x00000400,
            WimApplyFlagsMountLegacy   = 0x00000800
        }
        public enum WimMessage : uint {
            WIM_MSG                    = WM_APP + 0x1476,
            WIM_MSG_TEXT,
            WIM_MSG_PROGRESS,
            WIM_MSG_PROCESS,
            WIM_MSG_SCANNING,
            WIM_MSG_SETRANGE,
            WIM_MSG_SETPOS,
            WIM_MSG_STEPIT,
            WIM_MSG_COMPRESS,
            WIM_MSG_ERROR,
            WIM_MSG_ALIGNMENT,
            WIM_MSG_RETRY,
            WIM_MSG_SPLIT,
            WIM_MSG_SUCCESS            = 0x00000000,
            WIM_MSG_ABORT_IMAGE        = 0xFFFFFFFF
        }
        internal enum
        WimCreationDisposition
            : uint {
            WimOpenExisting            = 0x00000003,
        }
        internal enum
        WimActionFlags
            : uint {
            WimIgnored                 = 0x00000000
        }
        internal enum
        WimCompressionType
            : uint {
            WimIgnored                 = 0x00000000
        }
        internal enum
        WimCreationResult
            : uint {
            WimCreatedNew              = 0x00000000,
            WimOpenedExisting          = 0x00000001
        }
        #endregion WIMGAPI
        #endregion Enums and Flags
        #region Structs
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]
        public struct CreateVirtualDiskParameters {
            public CreateVirtualDiskVersion Version;
            public Guid UniqueId;
            public ulong MaximumSize;
            public uint BlockSizeInBytes;
            public uint SectorSizeInBytes;
            public string ParentPath;
            public string SourcePath;
            public OpenVirtualDiskFlags OpenFlags;
            public bool GetInfoOnly;
            public VirtualStorageType ParentVirtualStorageType;
            public VirtualStorageType SourceVirtualStorageType;
            public Guid ResiliencyGuid;
        }
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]
        public struct VirtualStorageType {
            public VirtualStorageDeviceType DeviceId;
            public Guid VendorId;
        }
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]
        public struct SecurityDescriptor {
            public byte revision;
            public byte size;
            public short control;
            public IntPtr owner;
            public IntPtr group;
            public IntPtr sacl;
            public IntPtr dacl;
        }
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]
        public struct
        OpenVirtualDiskParameters {
            public OpenVirtualDiskVersion Version;
            public bool GetInfoOnly;
            public Guid ResiliencyGuid;
        }
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]
        public struct VirtualDiskProgress {
            public int OperationStatus;
            public ulong CurrentValue;
            public ulong CompletionValue;
        }
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]
        public struct AttachVirtualDiskParameters {
            public AttachVirtualDiskVersion Version;
            public int Reserved;
        }
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]
        public struct CompactVirtualDiskParameters {
            public CompactVirtualDiskVersion Version;
            public uint Reserved;
        }
        #endregion Structs
        #region VirtDisk.DLL P/Invoke
        [DllImport("virtdisk.dll", CharSet = CharSet.Unicode)]
        public static extern uint
        CreateVirtualDisk(
            [In, Out] ref VirtualStorageType VirtualStorageType,
            [In]          string Path,
            [In]          VirtualDiskAccessMask VirtualDiskAccessMask,
            [In, Out] ref SecurityDescriptor SecurityDescriptor,
            [In]          CreateVirtualDiskFlags Flags,
            [In]          uint ProviderSpecificFlags,
            [In, Out] ref CreateVirtualDiskParameters Parameters,
            [In]          IntPtr Overlapped,
            [Out]     out SafeFileHandle Handle);
        [DllImport("virtdisk.dll", CharSet = CharSet.Unicode)]
        internal static extern uint
        OpenVirtualDisk(
            [In, Out] ref VirtualStorageType VirtualStorageType,
            [In]          string Path,
            [In]          VirtualDiskAccessMask VirtualDiskAccessMask,
            [In]          OpenVirtualDiskFlags Flags,
            [In, Out] ref OpenVirtualDiskParameters Parameters,
            [Out]     out SafeFileHandle Handle);
        [DllImport("virtdisk.dll", CharSet = CharSet.Unicode)]
        internal static extern uint
        GetVirtualDiskOperationProgress(
            [In]          SafeFileHandle VirtualDiskHandle,
            [In]          IntPtr Overlapped,
            [In, Out] ref VirtualDiskProgress Progress);
        [DllImport("virtdisk.dll", CharSet = CharSet.Unicode)]
        public static extern uint
        AttachVirtualDisk(
            [In]          SafeFileHandle VirtualDiskHandle,
            [In, Out] ref SecurityDescriptor SecurityDescriptor,
            [In]          AttachVirtualDiskFlags Flags,
            [In]          uint ProviderSpecificFlags,
            [In, Out] ref AttachVirtualDiskParameters Parameters,
            [In]          IntPtr Overlapped);
        [DllImport("virtdisk.dll", CharSet = CharSet.Unicode)]
        public static extern uint
        DetachVirtualDisk(
            [In]          SafeFileHandle VirtualDiskHandle,
            [In]          NativeMethods.DetachVirtualDiskFlag Flags,
            [In]          uint ProviderSpecificFlags);
        [DllImport("virtdisk.dll", CharSet = CharSet.Unicode)]
        public static extern uint
        CompactVirtualDisk(
            [In]          SafeFileHandle VirtualDiskHandle,
            [In]          CompactVirtualDiskFlags Flags,
            [In, Out] ref CompactVirtualDiskParameters Parameters,
            [In]          IntPtr Overlapped);
        [DllImport("virtdisk.dll", CharSet = CharSet.Unicode)]
        public static extern uint
        GetVirtualDiskPhysicalPath(
            [In]          SafeFileHandle VirtualDiskHandle,
            [In, Out] ref uint DiskPathSizeInBytes,
            [Out]         StringBuilder DiskPath);
        #endregion VirtDisk.DLL P/Invoke
        #region Win32 P/Invoke
        [DllImport("advapi32", SetLastError = true)]
        public static extern bool InitializeSecurityDescriptor(
            [Out]     out SecurityDescriptor pSecurityDescriptor,
            [In]          uint dwRevision);
        [DllImport("kernel32.dll", CharSet = CharSet.Unicode)]
        internal static extern IntPtr
        CreateEvent(
            [In, Optional]  IntPtr lpEventAttributes,
            [In]            bool bManualReset,
            [In]            bool bInitialState,
            [In, Optional]  string lpName);
        #endregion Win32 P/Invoke
        #region WIMGAPI P/Invoke
        #region SafeHandle wrappers for WimFileHandle and WimImageHandle
        public sealed class WimFileHandle : SafeHandle {
            public WimFileHandle(
                string wimPath)
                : base(IntPtr.Zero, true) {
                if (String.IsNullOrEmpty(wimPath)) {
                    throw new ArgumentNullException("wimPath");
                }
                if (!File.Exists(Path.GetFullPath(wimPath))) {
                    throw new FileNotFoundException((new FileNotFoundException()).Message, wimPath);
                }
                NativeMethods.WimCreationResult creationResult;
                this.handle = NativeMethods.WimCreateFile(
                    wimPath,
                    NativeMethods.WimCreateFileDesiredAccess.WimGenericRead,
                    NativeMethods.WimCreationDisposition.WimOpenExisting,
                    NativeMethods.WimActionFlags.WimIgnored,
                    NativeMethods.WimCompressionType.WimIgnored,
                    out creationResult
                );
                if (creationResult != NativeMethods.WimCreationResult.WimOpenedExisting) {
                    throw new Win32Exception();
                }
                if (this.handle == IntPtr.Zero) {
                    throw new Win32Exception();
                }
                NativeMethods.WimSetTemporaryPath(
                    this,
                    Environment.ExpandEnvironmentVariables("%TEMP%")
                );
            }
            protected override bool ReleaseHandle() {
                return NativeMethods.WimCloseHandle(this.handle);
            }
            public override bool IsInvalid {
                get { return this.handle == IntPtr.Zero; }
            }
        }
        public sealed class WimImageHandle : SafeHandle {
            public WimImageHandle(
                WimFile Container,
                uint ImageIndex)
                : base(IntPtr.Zero, true) {
                if (null == Container) {
                    throw new ArgumentNullException("Container");
                }
                if ((Container.Handle.IsClosed) || (Container.Handle.IsInvalid)) {
                    throw new ArgumentNullException("The handle to the WIM file has already been closed, or is invalid.", "Container");
                }
                if (ImageIndex > Container.ImageCount) {
                    throw new ArgumentOutOfRangeException("ImageIndex", "The index does not exist in the specified WIM file.");
                }
                this.handle = NativeMethods.WimLoadImage(
                    Container.Handle.DangerousGetHandle(),
                    ImageIndex);
            }
            protected override bool ReleaseHandle() {
                return NativeMethods.WimCloseHandle(this.handle);
            }
            public override bool IsInvalid {
                get { return this.handle == IntPtr.Zero; }
            }
        }
        #endregion SafeHandle wrappers for WimFileHandle and WimImageHandle
        [DllImport("Wimgapi.dll", CharSet = CharSet.Unicode, SetLastError = true, EntryPoint = "WIMCreateFile")]
        internal static extern IntPtr
        WimCreateFile(
            [In, MarshalAs(UnmanagedType.LPWStr)] string WimPath,
            [In]    WimCreateFileDesiredAccess DesiredAccess,
            [In]    WimCreationDisposition CreationDisposition,
            [In]    WimActionFlags FlagsAndAttributes,
            [In]    WimCompressionType CompressionType,
            [Out, Optional] out WimCreationResult CreationResult
        );
        [DllImport("Wimgapi.dll", CharSet = CharSet.Unicode, SetLastError = true, EntryPoint = "WIMCloseHandle")]
        [return: MarshalAs(UnmanagedType.Bool)]
        internal static extern bool
        WimCloseHandle(
            [In]    IntPtr Handle
        );
        [DllImport("Wimgapi.dll", CharSet = CharSet.Unicode, SetLastError = true, EntryPoint = "WIMLoadImage")]
        internal static extern IntPtr
        WimLoadImage(
            [In]    IntPtr Handle,
            [In]    uint ImageIndex
        );
        [DllImport("Wimgapi.dll", CharSet = CharSet.Unicode, SetLastError = true, EntryPoint = "WIMGetImageCount")]
        internal static extern uint
        WimGetImageCount(
            [In]    WimFileHandle Handle
        );
        [DllImport("Wimgapi.dll", CharSet = CharSet.Unicode, SetLastError = true, EntryPoint = "WIMApplyImage")]
        internal static extern bool
        WimApplyImage(
            [In]    WimImageHandle Handle,
            [In, Optional, MarshalAs(UnmanagedType.LPWStr)] string Path,
            [In]    WimApplyFlags Flags
        );
        [DllImport("Wimgapi.dll", CharSet = CharSet.Unicode, SetLastError = true, EntryPoint = "WIMGetImageInformation")]
        [return: MarshalAs(UnmanagedType.Bool)]
        internal static extern bool
        WimGetImageInformation(
            [In]        SafeHandle Handle,
            [Out]   out StringBuilder ImageInfo,
            [Out]   out uint SizeOfImageInfo
        );
        [DllImport("Wimgapi.dll", CharSet = CharSet.Unicode, SetLastError = true, EntryPoint = "WIMSetTemporaryPath")]
        [return: MarshalAs(UnmanagedType.Bool)]
        internal static extern bool
        WimSetTemporaryPath(
            [In]    WimFileHandle Handle,
            [In]    string TempPath
        );
        [DllImport("Wimgapi.dll", CharSet = CharSet.Unicode, SetLastError = true, EntryPoint = "WIMRegisterMessageCallback", CallingConvention = CallingConvention.StdCall)]
        internal static extern uint
        WimRegisterMessageCallback(
            [In, Optional] WimFileHandle      hWim,
            [In]           WimMessageCallback MessageProc,
            [In, Optional] IntPtr             ImageInfo
        );
        [DllImport("Wimgapi.dll", CharSet = CharSet.Unicode, SetLastError = true, EntryPoint = "WIMUnregisterMessageCallback", CallingConvention = CallingConvention.StdCall)]
        [return: MarshalAs(UnmanagedType.Bool)]
        internal static extern bool
        WimUnregisterMessageCallback(
            [In, Optional] WimFileHandle      hWim,
            [In]           WimMessageCallback MessageProc
        );
        #endregion WIMGAPI P/Invoke
    }
    #region WIM Interop
    public class WimFile {
        internal XDocument m_xmlInfo;
        internal List<WimImage> m_imageList;
        private static NativeMethods.WimMessageCallback wimMessageCallback;
        #region Events
        public delegate void DefaultImageEventHandler(object sender, DefaultImageEventArgs e);
        public delegate void ProcessFileEventHandler(object sender, ProcessFileEventArgs e);
        public event ProcessFileEventHandler ProcessFileEvent;
        public event DefaultImageEventHandler ProgressEvent;
        public event DefaultImageEventHandler ErrorEvent;
        public event DefaultImageEventHandler StepItEvent;
        public event DefaultImageEventHandler SetRangeEvent;
        public event DefaultImageEventHandler SetPosEvent;
        #endregion Events
        private
        enum
        ImageEventMessage : uint {
            Progress = NativeMethods.WimMessage.WIM_MSG_PROGRESS,
            Process = NativeMethods.WimMessage.WIM_MSG_PROCESS,
            Compress = NativeMethods.WimMessage.WIM_MSG_COMPRESS,
            Error = NativeMethods.WimMessage.WIM_MSG_ERROR,
            Alignment = NativeMethods.WimMessage.WIM_MSG_ALIGNMENT,
            Split = NativeMethods.WimMessage.WIM_MSG_SPLIT,
            Scanning = NativeMethods.WimMessage.WIM_MSG_SCANNING,
            SetRange = NativeMethods.WimMessage.WIM_MSG_SETRANGE,
            SetPos = NativeMethods.WimMessage.WIM_MSG_SETPOS,
            StepIt = NativeMethods.WimMessage.WIM_MSG_STEPIT,
            Success = NativeMethods.WimMessage.WIM_MSG_SUCCESS,
            Abort = NativeMethods.WimMessage.WIM_MSG_ABORT_IMAGE
        }
        private
        uint
        ImageEventMessagePump(
            uint MessageId,
            IntPtr wParam,
            IntPtr lParam,
            IntPtr UserData) {
            uint status = (uint) NativeMethods.WimMessage.WIM_MSG_SUCCESS;
            DefaultImageEventArgs eventArgs = new DefaultImageEventArgs(wParam, lParam, UserData);
            switch ((ImageEventMessage)MessageId) {
                case ImageEventMessage.Progress:
                    ProgressEvent(this, eventArgs);
                    break;
                case ImageEventMessage.Process:
                    if (null != ProcessFileEvent) {
                        string fileToImage = Marshal.PtrToStringUni(wParam);
                        ProcessFileEventArgs fileToProcess = new ProcessFileEventArgs(fileToImage, lParam);
                        ProcessFileEvent(this, fileToProcess);
                        if (fileToProcess.Abort == true) {
                            status = (uint)ImageEventMessage.Abort;
                        }
                    }
                    break;
                case ImageEventMessage.Error:
                    if (null != ErrorEvent) {
                        ErrorEvent(this, eventArgs);
                    }
                    break;
                case ImageEventMessage.SetRange:
                    if (null != SetRangeEvent) {
                        SetRangeEvent(this, eventArgs);
                    }
                    break;
                case ImageEventMessage.SetPos:
                    if (null != SetPosEvent) {
                        SetPosEvent(this, eventArgs);
                    }
                    break;
                case ImageEventMessage.StepIt:
                    if (null != StepItEvent) {
                        StepItEvent(this, eventArgs);
                    }
                    break;
                default:
                    break;
            }
            return status;
        }
        public
        WimFile(string wimPath) {
            if (string.IsNullOrEmpty(wimPath)) {
                throw new ArgumentNullException("wimPath");
            }
            if (!File.Exists(Path.GetFullPath(wimPath))) {
                throw new FileNotFoundException((new FileNotFoundException()).Message, wimPath);
            }
            Handle = new NativeMethods.WimFileHandle(wimPath);
        }
        public void
        Close() {
            foreach (WimImage image in Images) {
                image.Close();
            }
            if (null != wimMessageCallback) {
                NativeMethods.UnregisterMessageCallback(this.Handle, wimMessageCallback);
                wimMessageCallback = null;
            }
            if ((!Handle.IsClosed) && (!Handle.IsInvalid)) {
                Handle.Close();
            }
        }
        public List<WimImage>
        Images {
            get {
                if (null == m_imageList) {
                    int imageCount = (int)ImageCount;
                    m_imageList = new List<WimImage>(imageCount);
                    for (int i = 0; i < imageCount; i++) {
                        m_imageList.Add(
                            new WimImage(this, (uint)i + 1));
                    }
                }
                return m_imageList;
            }
        }
        public List<string>
        ImageNames {
            get {
                List<string> nameList = new List<string>();
                foreach (WimImage image in Images) {
                    nameList.Add(image.ImageName);
                }
                return nameList;
            }
        }
        public WimImage
        this[int ImageIndex] {
            get { return Images[ImageIndex - 1]; }
        }
        public WimImage
        this[string ImageName] {
            get {
                return
                    Images.Where(i => (
                        i.ImageName.ToUpper()  == ImageName.ToUpper() ||
                        i.ImageFlags.ToUpper() == ImageName.ToUpper() ))
                    .DefaultIfEmpty(null)
                        .FirstOrDefault<WimImage>();
            }
        }
        internal uint
        ImageCount {
            get { return NativeMethods.WimGetImageCount(Handle); }
        }
        internal XDocument
        XmlInfo {
            get {
                if (null == m_xmlInfo) {
                    StringBuilder builder;
                    uint bytes;
                    if (!NativeMethods.WimGetImageInformation(Handle, out builder, out bytes)) {
                        throw new Win32Exception();
                    }
                    int charCount = (int)bytes / sizeof(char);
                    if (null != builder) {
                        builder.Remove(0, 1);
                        builder.EnsureCapacity(charCount - 1);
                        builder.Length = charCount - 1;
                        m_xmlInfo = XDocument.Parse(builder.ToString().Trim());
                    } else {
                        m_xmlInfo = null;
                    }
                }
                return m_xmlInfo;
            }
        }
        public NativeMethods.WimFileHandle Handle {
            get;
            private set;
        }
    }
    public class
    WimImage {
        internal XDocument m_xmlInfo;
        public
        WimImage(
            WimFile Container,
            uint ImageIndex) {
            if (null == Container) {
                throw new ArgumentNullException("Container");
            }
            if ((Container.Handle.IsClosed) || (Container.Handle.IsInvalid)) {
                throw new ArgumentNullException("The handle to the WIM file has already been closed, or is invalid.", "Container");
            }
            if (ImageIndex > Container.ImageCount) {
                throw new ArgumentOutOfRangeException("ImageIndex", "The index does not exist in the specified WIM file.");
            }
            Handle = new NativeMethods.WimImageHandle(Container, ImageIndex);
        }
        public enum
        Architectures : uint {
            x86   = 0x0,
            ARM   = 0x5,
            IA64  = 0x6,
            AMD64 = 0x9
        }
        public void
        Close() {
            if ((!Handle.IsClosed) && (!Handle.IsInvalid)) {
                Handle.Close();
            }
        }
        public void
        Apply(
            string ApplyToPath) {
            if (string.IsNullOrEmpty(ApplyToPath)) {
                throw new ArgumentNullException("ApplyToPath");
            }
            ApplyToPath = Path.GetFullPath(ApplyToPath);
            if (!Directory.Exists(ApplyToPath)) {
                throw new DirectoryNotFoundException("The WIM cannot be applied because the specified directory was not found.");
            }
            if (!NativeMethods.WimApplyImage(
                this.Handle,
                ApplyToPath,
                NativeMethods.WimApplyFlags.WimApplyFlagsNone
            )) {
                throw new Win32Exception();
            }
        }
        public NativeMethods.WimImageHandle
        Handle {
            get;
            private set;
        }
        internal XDocument
        XmlInfo {
            get {
                if (null == m_xmlInfo) {
                    StringBuilder builder;
                    uint bytes;
                    if (!NativeMethods.WimGetImageInformation(Handle, out builder, out bytes)) {
                        throw new Win32Exception();
                    }
                    int charCount = (int)bytes / sizeof(char);
                    if (null != builder) {
                        builder.Remove(0, 1);
                        builder.EnsureCapacity(charCount - 1);
                        builder.Length = charCount - 1;
                        m_xmlInfo = XDocument.Parse(builder.ToString().Trim());
                    } else {
                        m_xmlInfo = null;
                    }
                }
                return m_xmlInfo;
            }
        }
        public string
        ImageIndex {
            get { return XmlInfo.Element("IMAGE").Attribute("INDEX").Value; }
        }
        public string
        ImageName {
            get { return XmlInfo.XPathSelectElement("/IMAGE/NAME").Value; }
        }
        public string
        ImageEditionId {
            get { return XmlInfo.XPathSelectElement("/IMAGE/WINDOWS/EDITIONID").Value; }
        }
        public string
        ImageFlags {
            get { return XmlInfo.XPathSelectElement("/IMAGE/FLAGS").Value; }
        }
        public string
        ImageProductType {
            get {
                return XmlInfo.XPathSelectElement("/IMAGE/WINDOWS/PRODUCTTYPE").Value;
            }
        }
        public string
        ImageInstallationType {
            get { return XmlInfo.XPathSelectElement("/IMAGE/WINDOWS/INSTALLATIONTYPE").Value; }
        }
        public string
        ImageDescription {
            get { return XmlInfo.XPathSelectElement("/IMAGE/DESCRIPTION").Value; }
        }
        public ulong
        ImageSize {
            get { return ulong.Parse(XmlInfo.XPathSelectElement("/IMAGE/TOTALBYTES").Value); }
        }
        public Architectures
        ImageArchitecture {
            get {
                int arch = -1;
                try {
                    arch = int.Parse(XmlInfo.XPathSelectElement("/IMAGE/WINDOWS/ARCH").Value);
                } catch { }
                return (Architectures)arch;
            }
        }
        public string
        ImageDefaultLanguage {
            get {
                string lang = null;
                try {
                    lang = XmlInfo.XPathSelectElement("/IMAGE/WINDOWS/LANGUAGES/DEFAULT").Value;
                } catch { }
                return lang;
            }
        }
        public Version
        ImageVersion {
            get {
                int major = 0;
                int minor = 0;
                int build = 0;
                int revision = 0;
                try {
                    major = int.Parse(XmlInfo.XPathSelectElement("/IMAGE/WINDOWS/VERSION/MAJOR").Value);
                    minor = int.Parse(XmlInfo.XPathSelectElement("/IMAGE/WINDOWS/VERSION/MINOR").Value);
                    build = int.Parse(XmlInfo.XPathSelectElement("/IMAGE/WINDOWS/VERSION/BUILD").Value);
                    revision = int.Parse(XmlInfo.XPathSelectElement("/IMAGE/WINDOWS/VERSION/SPBUILD").Value);
                } catch { }
                return (new Version(major, minor, build, revision));
            }
        }
        public string
        ImageDisplayName {
            get { return XmlInfo.XPathSelectElement("/IMAGE/DISPLAYNAME").Value; }
        }
        public string
        ImageDisplayDescription {
            get { return XmlInfo.XPathSelectElement("/IMAGE/DISPLAYDESCRIPTION").Value; }
        }
    }
    public class
    DefaultImageEventArgs : EventArgs {
        public
        DefaultImageEventArgs(
            IntPtr wideParameter,
            IntPtr leftParameter,
            IntPtr userData) {
            WideParameter = wideParameter;
            LeftParameter = leftParameter;
            UserData      = userData;
        }
        public IntPtr WideParameter {
            get;
            private set;
        }
        public IntPtr LeftParameter {
            get;
            private set;
        }
        public IntPtr UserData {
            get;
            private set;
        }
    }
    public class
    ProcessFileEventArgs : EventArgs {
        public
        ProcessFileEventArgs(
            string file,
            IntPtr skipFileFlag) {
            m_FilePath = file;
            m_SkipFileFlag = skipFileFlag;
        }
        public void
        SkipFile() {
            byte[] byteBuffer = {
                    0
            };
            int byteBufferSize = byteBuffer.Length;
            Marshal.Copy(byteBuffer, 0, m_SkipFileFlag, byteBufferSize);
        }
        public string
        FilePath {
            get {
                string stringToReturn = "";
                if (m_FilePath != null) {
                    stringToReturn = m_FilePath;
                }
                return stringToReturn;
            }
        }
        public bool Abort {
            set { m_Abort = value; }
            get { return m_Abort;  }
        }
        private string m_FilePath;
        private bool m_Abort;
        private IntPtr m_SkipFileFlag;
    }
    #endregion WIM Interop
    #region VHD Interop
    public class
    VirtualHardDisk : IDisposable {
        #region Member Variables
        private SafeFileHandle m_virtualHardDiskHandle = null;
        private string m_filePath = null;
        private bool m_isDisposed;
        private NativeMethods.VirtualStorageDeviceType m_deviceType = NativeMethods.VirtualStorageDeviceType.Unknown;
        #endregion Member Variables
        #region IDisposable Members
        public void
        Dispose() {
            this.Dispose(true);
            GC.SuppressFinalize(this);
        }
        public void
        Dispose(
            bool disposing) {
            if (!this.m_isDisposed) {
                if (disposing) {
                    if (this.DiskIndex != 0) {
                        this.Close();
                    }
                }
                m_isDisposed = true;
            }
        }
        #endregion IDisposable Members
        #region Constructor
        private VirtualHardDisk(
            SafeFileHandle Handle,
            string Path,
            NativeMethods.VirtualStorageDeviceType DeviceType) {
            if (Handle.IsInvalid || Handle.IsClosed) {
                throw new InvalidOperationException("The handle to the Virtual Hard Disk is invalid.");
            }
            m_virtualHardDiskHandle = Handle;
            m_filePath = Path;
            m_deviceType = DeviceType;
        }
        #endregion Constructor
        #region Gozer the Destructor
        ~VirtualHardDisk() {
            this.Dispose(false);
        }
        #endregion Gozer the Destructor
        #region Static Methods
        #region Sparse Disks
        public static VirtualHardDisk
        CreateSparseDisk(
            NativeMethods.VirtualStorageDeviceType virtualStorageDeviceType,
            string path,
            ulong size,
            bool overwrite) {
            return CreateSparseDisk(
                path,
                size,
                overwrite,
                null,
                IntPtr.Zero,
                (virtualStorageDeviceType == NativeMethods.VirtualStorageDeviceType.VHD)
                    ? NativeMethods.DEFAULT_BLOCK_SIZE
                    : 0,
                virtualStorageDeviceType,
                NativeMethods.DISK_SECTOR_SIZE);
        }
        public static VirtualHardDisk
        CreateSparseDisk(
            string path,
            ulong size,
            bool overwrite,
            string source,
            IntPtr overlapped,
            uint blockSizeInBytes,
            NativeMethods.VirtualStorageDeviceType virtualStorageDeviceType,
            uint sectorSizeInBytes) {
            if (virtualStorageDeviceType != NativeMethods.VirtualStorageDeviceType.VHD && virtualStorageDeviceType != NativeMethods.VirtualStorageDeviceType.VHDX) {
                throw (
                    new ArgumentOutOfRangeException(
                        "virtualStorageDeviceType",
                        virtualStorageDeviceType,
                        "VirtualStorageDeviceType must be VHD or VHDX."
                ));
            }
            if ((size % NativeMethods.DISK_SECTOR_SIZE) != 0) {
                throw (
                    new ArgumentOutOfRangeException(
                        "size",
                        size,
                        "The size of the virtual disk must be a multiple of 512."
                ));
            }
            if ((!String.IsNullOrEmpty(source)) && (!System.IO.File.Exists(source))) {
                throw (
                    new System.IO.FileNotFoundException(
                        "Unable to find the source file.",
                        source
                ));
            }
            if ((overwrite) && (System.IO.File.Exists(path))) {
                System.IO.File.Delete(path);
            }
            NativeMethods.CreateVirtualDiskParameters createParams = new NativeMethods.CreateVirtualDiskParameters();
            createParams.Version = (virtualStorageDeviceType == NativeMethods.VirtualStorageDeviceType.VHD)
                ? NativeMethods.CreateVirtualDiskVersion.Version1
                : NativeMethods.CreateVirtualDiskVersion.Version2;
            createParams.UniqueId                 = Guid.NewGuid();
            createParams.MaximumSize              = size;
            createParams.BlockSizeInBytes         = blockSizeInBytes;
            createParams.SectorSizeInBytes        = sectorSizeInBytes;
            createParams.ParentPath               = null;
            createParams.SourcePath               = source;
            createParams.OpenFlags                = NativeMethods.OpenVirtualDiskFlags.None;
            createParams.GetInfoOnly              = false;
            createParams.ParentVirtualStorageType = new NativeMethods.VirtualStorageType();
            createParams.SourceVirtualStorageType = new NativeMethods.VirtualStorageType();
            NativeMethods.SecurityDescriptor securityDescriptor;
            if (!NativeMethods.InitializeSecurityDescriptor(out securityDescriptor, 1)) {
                throw (
                    new SecurityException(
                        "Unable to initialize the security descriptor for the virtual disk."
                ));
            }
            NativeMethods.VirtualStorageType virtualStorageType = new NativeMethods.VirtualStorageType();
            virtualStorageType.DeviceId = virtualStorageDeviceType;
            virtualStorageType.VendorId = NativeMethods.VirtualStorageTypeVendorMicrosoft;
            SafeFileHandle vhdHandle;
            uint returnCode = NativeMethods.CreateVirtualDisk(
                ref virtualStorageType,
                    path,
                    (virtualStorageDeviceType == NativeMethods.VirtualStorageDeviceType.VHD)
                        ? NativeMethods.VirtualDiskAccessMask.All
                        : NativeMethods.VirtualDiskAccessMask.None,
                ref securityDescriptor,
                    NativeMethods.CreateVirtualDiskFlags.None,
                    0,
                ref createParams,
                    overlapped,
                out vhdHandle);
            if (NativeMethods.ERROR_SUCCESS != returnCode && NativeMethods.ERROR_IO_PENDING != returnCode) {
                throw (
                    new Win32Exception(
                        (int)returnCode
                ));
            }
            return new VirtualHardDisk(vhdHandle, path, virtualStorageDeviceType);
        }
        #endregion Sparse Disks
        #region Fixed Disks
        public static VirtualHardDisk
        CreateFixedDisk(
            NativeMethods.VirtualStorageDeviceType virtualStorageDeviceType,
            string path,
            ulong size,
            bool overwrite) {
            return CreateFixedDisk(
                path,
                size,
                overwrite,
                null,
                IntPtr.Zero,
                0,
                virtualStorageDeviceType,
                NativeMethods.DISK_SECTOR_SIZE);
        }
        public static VirtualHardDisk
        CreateFixedDisk(
            string path,
            ulong size,
            bool overwrite,
            string source,
            IntPtr overlapped,
            uint blockSizeInBytes,
            NativeMethods.VirtualStorageDeviceType virtualStorageDeviceType,
            uint sectorSizeInBytes) {
            if (virtualStorageDeviceType != NativeMethods.VirtualStorageDeviceType.VHD && virtualStorageDeviceType != NativeMethods.VirtualStorageDeviceType.VHDX) {
                throw (
                    new ArgumentOutOfRangeException(
                        "virtualStorageDeviceType",
                        virtualStorageDeviceType,
                        "VirtualStorageDeviceType must be VHD or VHDX."
                ));
            }
            if ((size % NativeMethods.DISK_SECTOR_SIZE) != 0) {
                throw (
                    new ArgumentOutOfRangeException(
                        "size",
                        size,
                        "The size of the virtual disk must be a multiple of 512."
                ));
            }
            if ((!String.IsNullOrEmpty(source)) && (!System.IO.File.Exists(source))) {
                throw (
                    new System.IO.FileNotFoundException(
                        "Unable to find the source file.",
                        source
                ));
            }
            if ((overwrite) && (System.IO.File.Exists(path))) {
                System.IO.File.Delete(path);
            }
            NativeMethods.CreateVirtualDiskParameters createParams = new NativeMethods.CreateVirtualDiskParameters();
            createParams.Version = (virtualStorageDeviceType == NativeMethods.VirtualStorageDeviceType.VHD)
                ? NativeMethods.CreateVirtualDiskVersion.Version1
                : NativeMethods.CreateVirtualDiskVersion.Version2;
            createParams.UniqueId                 = Guid.NewGuid();
            createParams.MaximumSize              = size;
            createParams.BlockSizeInBytes         = blockSizeInBytes;
            createParams.SectorSizeInBytes        = sectorSizeInBytes;
            createParams.ParentPath               = null;
            createParams.SourcePath               = source;
            createParams.OpenFlags                = NativeMethods.OpenVirtualDiskFlags.None;
            createParams.GetInfoOnly              = false;
            createParams.ParentVirtualStorageType = new NativeMethods.VirtualStorageType();
            createParams.SourceVirtualStorageType = new NativeMethods.VirtualStorageType();
            NativeMethods.SecurityDescriptor securityDescriptor;
            if (!NativeMethods.InitializeSecurityDescriptor(out securityDescriptor, 1)) {
                throw (
                    new SecurityException(
                        "Unable to initialize the security descriptor for the virtual disk."
                ));
            }
            NativeMethods.VirtualStorageType virtualStorageType = new NativeMethods.VirtualStorageType();
            virtualStorageType.DeviceId = virtualStorageDeviceType;
            virtualStorageType.VendorId = NativeMethods.VirtualStorageTypeVendorMicrosoft;
            SafeFileHandle vhdHandle;
            uint returnCode = NativeMethods.CreateVirtualDisk(
                ref virtualStorageType,
                    path,
                    (virtualStorageDeviceType == NativeMethods.VirtualStorageDeviceType.VHD)
                        ? NativeMethods.VirtualDiskAccessMask.All
                        : NativeMethods.VirtualDiskAccessMask.None,
                ref securityDescriptor,
                    NativeMethods.CreateVirtualDiskFlags.FullPhysicalAllocation,
                    0,
                ref createParams,
                    overlapped,
                out vhdHandle);
            if (NativeMethods.ERROR_SUCCESS != returnCode && NativeMethods.ERROR_IO_PENDING != returnCode) {
                throw (
                    new Win32Exception(
                        (int)returnCode
                ));
            }
            return new VirtualHardDisk(vhdHandle, path, virtualStorageDeviceType);
        }
        #endregion Fixed Disks
        #region Open
        public static VirtualHardDisk
        Open(
            string path,
            NativeMethods.VirtualDiskAccessMask accessMask,
            uint readWriteDepth,
            NativeMethods.OpenVirtualDiskFlags flags,
            NativeMethods.VirtualStorageDeviceType virtualStorageDeviceType) {
            if (!File.Exists(path)) {
                throw new FileNotFoundException("The specified VHD was not found.  Please check your path and try again.", path);
            }
            NativeMethods.OpenVirtualDiskParameters openParams = new NativeMethods.OpenVirtualDiskParameters();
            openParams.Version = (virtualStorageDeviceType == NativeMethods.VirtualStorageDeviceType.VHD)
                ? NativeMethods.OpenVirtualDiskVersion.Version1
                : NativeMethods.OpenVirtualDiskVersion.Version2;
            openParams.GetInfoOnly = false;
            NativeMethods.VirtualStorageType virtualStorageType = new NativeMethods.VirtualStorageType();
            virtualStorageType.DeviceId = virtualStorageDeviceType;
            virtualStorageType.VendorId = (virtualStorageDeviceType == NativeMethods.VirtualStorageDeviceType.Unknown)
                ? virtualStorageType.VendorId = NativeMethods.VirtualStorageTypeVendorUnknown
                : virtualStorageType.VendorId = NativeMethods.VirtualStorageTypeVendorMicrosoft;
            SafeFileHandle vhdHandle;
            uint returnCode = NativeMethods.OpenVirtualDisk(
                ref virtualStorageType,
                    path,
                    accessMask,
                    flags,
                ref openParams,
                out vhdHandle);
            if (NativeMethods.ERROR_SUCCESS != returnCode) {
                throw new Win32Exception((int)returnCode);
            }
            return new VirtualHardDisk(vhdHandle, path, virtualStorageDeviceType);
        }
        #endregion Open
        #region Other
        public static ReadOnlyCollection<Char>
        GetAvailableDriveLetters() {
            List<Char> availableDrives = new List<Char>();
            for (int i = (byte)'C'; i <= (byte)'Z'; i++) {
                availableDrives.Add((char)i);
            }
            foreach (string drive in System.Environment.GetLogicalDrives()) {
                availableDrives.Remove(drive.ToUpper(CultureInfo.InvariantCulture)[0]);
            }
            return new ReadOnlyCollection<char>(availableDrives);
        }
        public static char
        GetFirstAvailableDriveLetter() {
            return GetAvailableDriveLetters()[0];
        }
        #endregion Other
        #endregion Static Methods
        #region AsyncHelpers
        public static GCHandle
        CreatePinnedOverlappedObject() {
            NativeOverlapped overlapped = new NativeOverlapped();
            overlapped.EventHandle = NativeMethods.CreateEvent(IntPtr.Zero, true, false, null);
            GCHandle handleForOverllapped = GCHandle.Alloc(overlapped, GCHandleType.Pinned);
            return handleForOverllapped;
        }
        public uint
        GetVirtualDiskOperationProgress(
            ref NativeMethods.VirtualDiskProgress progress,
                IntPtr overlapped) {
            uint returnCode = NativeMethods.GetVirtualDiskOperationProgress(
                    this.m_virtualHardDiskHandle,
                    overlapped,
                ref progress);
            return returnCode;
        }
        #endregion AsyncHelpers
        #region Public Methods
        public void
        Close() {
            m_virtualHardDiskHandle.Close();
        }
        public void
        Attach(
            NativeMethods.AttachVirtualDiskFlags attachVirtualDiskFlags) {
            if (!this.IsAttached) {
                int diskIndex = this.DiskIndex;
                NativeMethods.AttachVirtualDiskParameters attachParameters = new NativeMethods.AttachVirtualDiskParameters();
                attachParameters.Version = NativeMethods.AttachVirtualDiskVersion.Version1;
                attachParameters.Reserved = 0;
                NativeMethods.SecurityDescriptor securityDescriptor;
                if (!NativeMethods.InitializeSecurityDescriptor(out securityDescriptor, 1)) {
                    throw (new SecurityException("Unable to initialize the security descriptor for the virtual disk."));
                }
                uint returnCode = NativeMethods.AttachVirtualDisk(
                         m_virtualHardDiskHandle,
                    ref  securityDescriptor,
                         attachVirtualDiskFlags,
                         0,
                    ref  attachParameters,
                         IntPtr.Zero);
                switch (returnCode) {
                    case NativeMethods.ERROR_SUCCESS:
                        break;
                    default:
                        throw new Win32Exception((int)returnCode);
                }
                short attempts = 5;
                while ((attempts-- >= 0) && (diskIndex == this.DiskIndex)) {
                    System.Threading.Thread.Sleep(1000);
                }
            }
        }
        public void
        Attach() {
            this.Attach(NativeMethods.AttachVirtualDiskFlags.None);
        }
        public void
        Detach() {
            if (this.IsAttached) {
                uint returnCode = NativeMethods.DetachVirtualDisk(
                    m_virtualHardDiskHandle,
                    NativeMethods.DetachVirtualDiskFlag.None,
                    0);
                switch (returnCode) {
                    case NativeMethods.ERROR_NOT_FOUND:
                    case NativeMethods.ERROR_SUCCESS:
                        break;
                    default:
                        throw new Win32Exception((int)returnCode);
                }
            }
        }
        public uint
        Compact(IntPtr overlapped) {
            return this.Compact(
                overlapped,
                NativeMethods.CompactVirtualDiskFlags.None);
        }
        public uint
        Compact(
            IntPtr overlapped,
            NativeMethods.CompactVirtualDiskFlags flags) {
            NativeMethods.CompactVirtualDiskParameters compactParams = new NativeMethods.CompactVirtualDiskParameters();
            compactParams.Version = NativeMethods.CompactVirtualDiskVersion.Version1;
            uint returnCode = NativeMethods.CompactVirtualDisk(
                m_virtualHardDiskHandle,
                flags,
            ref compactParams,
                overlapped);
            if ((overlapped == IntPtr.Zero && NativeMethods.ERROR_SUCCESS != returnCode) ||
                (overlapped != IntPtr.Zero && NativeMethods.ERROR_IO_PENDING != returnCode)) {
                throw new Win32Exception((int)returnCode);
            }
            return returnCode;
        }
        #endregion Public Methods
        #region Public Properties
        public SafeFileHandle
        VirtualHardDiskHandle {
            get {
                return m_virtualHardDiskHandle;
            }
        }
        public int
        DiskIndex {
            get {
                string path = PhysicalPath;
                if (null != path) {
                    Match match = Regex.Match(path, @"\d+$");
                    return System.Convert.ToInt32(match.Value, CultureInfo.InvariantCulture);
                } else {
                    return -1;
                }
            }
        }
        public bool
        IsAttached {
            get {
                return (this.DiskIndex != -1);
            }
        }
        public string
        PhysicalPath {
            get {
                uint pathSize = 1024;
                StringBuilder path = new StringBuilder((int)pathSize);
                uint returnCode = 0;
                returnCode = NativeMethods.GetVirtualDiskPhysicalPath(
                        m_virtualHardDiskHandle,
                    ref pathSize,
                        path);
                if (NativeMethods.ERROR_ERROR_DEV_NOT_EXIST == returnCode) {
                    return null;
                } else if (NativeMethods.ERROR_SUCCESS == returnCode) {
                    return path.ToString();
                } else {
                    throw new Win32Exception((int)returnCode);
                }
            }
        }
        #endregion Public Properties
    }
    #endregion VHD Interop
}
