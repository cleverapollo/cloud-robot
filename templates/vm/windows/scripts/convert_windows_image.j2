function Convert-WindowsImage {
    [CmdletBinding(DefaultParameterSetName="SRC",
    HelpURI="http://gallery.technet.microsoft.com/scriptcenter/Convert-WindowsImageps1-0fe23a8f")]
    param(
        [Parameter(ParameterSetName="SRC", Mandatory=$true, ValueFromPipeline=$true)]
        [Alias("WIM")]
        [string]
        [ValidateNotNullOrEmpty()]
        [ValidateScript({ Test-Path $(Resolve-Path $_) })]
        $SourcePath,
        [Parameter(ParameterSetName="SRC")]
        [Alias("SKU")]
        [string[]]
        [ValidateNotNullOrEmpty()]
        $Edition,
        [Parameter(ParameterSetName="SRC")]
        [Alias("WorkDir")]
        [string]
        [ValidateNotNullOrEmpty()]
        [ValidateScript({ Test-Path $_ })]
        $WorkingDirectory,
        [Parameter(ParameterSetName="SRC")]
        [Alias("VHD")]
        [string]
        [ValidateNotNullOrEmpty()]
        $VHDPath,
        [Parameter(ParameterSetName="SRC")]
        [Alias("Size")]
        [UInt64]
        [ValidateNotNullOrEmpty()]
        [ValidateRange(512MB, 64TB)]
        $SizeBytes,
        [Parameter(ParameterSetName="SRC")]
        [Alias("Format")]
        [string]
        [ValidateNotNullOrEmpty()]
        [ValidateSet("VHD", "VHDX")]
        $VHDFormat,
        [Parameter(ParameterSetName="SRC")]
        [Alias("DiskType")]
        [string]
        [ValidateNotNullOrEmpty()]
        [ValidateSet("Dynamic", "Fixed")]
        $VHDType,
        [Parameter(ParameterSetName="SRC")]
        [string]
        [ValidateNotNullOrEmpty()]
        [ValidateSet("MBR", "GPT")]
        $VHDPartitionStyle,
        [Parameter(ParameterSetName="SRC")]
        [string]
        [ValidateNotNullOrEmpty()]
        [ValidateSet("NativeBoot", "VirtualMachine")]
        $BCDinVHD = "VirtualMachine",
        [Parameter(ParameterSetName="SRC")]
        [Parameter(ParameterSetName="UI")]
        [string]
        $BCDBoot = "bcdboot.exe",
        [Parameter(ParameterSetName="SRC")]
        [string[]]
        [ValidateNotNullOrEmpty()]
        $Feature,
        [Parameter(ParameterSetName="SRC")]
        [string[]]
        [ValidateNotNullOrEmpty()]
        [ValidateScript({ Test-Path $(Resolve-Path $_) })]
        $Driver,
        [Parameter(ParameterSetName="SRC")]
        [string[]]
        [ValidateNotNullOrEmpty()]
        [ValidateScript({ Test-Path $(Resolve-Path $_) })]
        $Package,
        [Parameter(ParameterSetName="SRC")]
        [Switch]
        $ExpandOnNativeBoot = $True,
        [Parameter(ParameterSetName="SRC")]
        [Switch]
        $RemoteDesktopEnable = $True,
        [Parameter(ParameterSetName="SRC")]
        [Alias("Unattend")]
        [string]
        [ValidateNotNullOrEmpty()]
        [ValidateScript({ Test-Path $(Resolve-Path $_) })]
        $UnattendPath,
        [Parameter(ParameterSetName="SRC")]
        [Parameter(ParameterSetName="UI")]
        [switch]
        $Passthru
    )
    DynamicParam {
        $parameterDictionary = New-Object System.Management.Automation.RuntimeDefinedParameterDictionary
        return $parameterDictionary
    }
    Begin {
        $PARTITION_STYLE_MBR    = 0x00000000
        $PARTITION_STYLE_GPT    = 0x00000001
        $ScriptVersion = DATA {
            ConvertFrom-StringData -StringData @"
        Major     = 10
        Minor     = 0
        Build     = 9000
        QFE       = 0
        Branch    = fbl_core1_hyp_dev(mikekol)
        Timestamp = 141224-3000
        Flavor    = amd64fre
"@
        }
        $vQuality = "Beta"

        $myVersion = "$($ScriptVersion.Major).$($ScriptVersion.Minor).$($ScriptVersion.Build).$($ScriptVersion.QFE).$($ScriptVersion.Flavor).$($ScriptVersion.Branch).$($ScriptVersion.Timestamp)"
        $scriptName = "Convert-WindowsImage"
        $sessionKey = [Guid]::NewGuid().ToString()
        $logFolder = "$($env:Temp)\$($scriptName)\$($sessionKey)"
        $vhdMaxSize = 2040GB
        $vhdxMaxSize = 64TB
        $lowestSupportedVersion = New-Object Version "6.1"
        $lowestSupportedBuild = 8250
        $transcripting = $false
        $VHDFormat              = $VHDFormat.ToUpper()
        $flagText = @"
This $VHDFormat was created by Convert-WindowsImage.ps1 $myVersion $vQuality
on $([DateTime]::Now).
"@
        $header = @"

Windows(R) Image to Virtual Hard Disk Converter for Windows(R) 10
Copyright (C) Microsoft Corporation.  All rights reserved.
Version $myVersion $vQuality

"@
        $code = Get-Content -Path "Z:\HyperV\scripts\vim2vhd.cs" -Raw
        Function Mount-RegistryHive {
            [CmdletBinding()]
            param(
                [Parameter(Mandatory = $true, ValueFromPipeline = $true, Position = 0)]
                [System.IO.FileInfo]
                [ValidateNotNullOrEmpty()]
                [ValidateScript({ $_.Exists })]
                $Hive
            )
            $mountKey = [System.Guid]::NewGuid().ToString()
            $regPath  = "REG.EXE"
            if (Test-Path HKLM:\$mountKey) {
                throw "The registry path already exists.  I should just regenerate it, but I'm lazy."
            }
            $regArgs = (
                "LOAD",
                "HKLM\$mountKey",
                $Hive.Fullname
            )
            try {
                Run-Executable -Executable $regPath -Arguments $regArgs

            } catch {
                throw
            }
            $global:mountedHive = $mountKey
            return $mountKey
        }
        Function Dismount-RegistryHive {
            [CmdletBinding()]
            param(
                [Parameter(Mandatory = $true, ValueFromPipeline = $true, Position = 0)]
                [string]
                [ValidateNotNullOrEmpty()]
                $HiveMountPoint
            )
            $regPath = "REG.EXE"
            $regArgs = (
                "UNLOAD",
                "HKLM\$($HiveMountPoint)"
            )
            Run-Executable -Executable $regPath -Arguments $regArgs
            $global:mountedHive = $null
        }

        Function Apply-BCDStoreChanges {
            [CmdletBinding()]
            param(
                [Parameter(Mandatory = $true)]
                [string]
                [ValidateNotNullOrEmpty()]
                $BcdStoreFile,
                [Parameter()]
                [string]
                [ValidateNotNullOrEmpty()]
                [ValidateScript({ ($_ -eq $PARTITION_STYLE_MBR) -or ($_ -eq $PARTITION_STYLE_GPT) })]
                $PartitionStyle = $PARTITION_STYLE_MBR,
                [Parameter()]
                [UInt64]
                [ValidateScript({ $_ -ge 0 })]
                $DiskSignature,
                [Parameter()]
                [UInt64]
                [ValidateScript({ $_ -ge 0 })]
                $PartitionOffset
            )
            $BOOTMGR_ID              = "{9DEA862C-5CDD-4E70-ACC1-F32B344D4795}"
            $DEFAULT_TYPE            = 0x23000003
            $APPLICATION_DEVICE_TYPE = 0x11000001
            $OS_DEVICE_TYPE          = 0x21000001
            Write-W2VInfo "Opening $($BcdStoreFile) for configuration..."
            Write-W2VTrace "Partition Style : $PartitionStyle"
            Write-W2VTrace "Disk Signature  : $DiskSignature"
            Write-W2VTrace "Partition Offset: $PartitionOffset"
            $conn    = New-Object Management.ConnectionOptions
            $scope   = New-Object Management.ManagementScope -ArgumentList "\\.\ROOT\WMI", $conn
            $scope.Connect()
            $path    = New-Object Management.ManagementPath `
                       -ArgumentList "\\.\ROOT\WMI:BCDObject.Id=`"$($BOOTMGR_ID)`",StoreFilePath=`"$($BcdStoreFile.Replace('\', '\\'))`""
            $options = New-Object Management.ObjectGetOptions
            $bootMgr = New-Object Management.ManagementObject -ArgumentList $scope, $path, $options
            try {
                $bootMgr.Get()
            } catch {
                throw "Could not get the BootMgr object from the Virtual Disks BCDStore."
            }
            Write-W2VTrace "Setting Qualified Partition Device Element for Virtual Disk boot..."
            $ret = $bootMgr.SetQualifiedPartitionDeviceElement($APPLICATION_DEVICE_TYPE, $PartitionStyle, $DiskSignature, $PartitionOffset)
            if (!$ret.ReturnValue) {
                throw "Unable to set Qualified Partition Device Element in Virtual Disks BCDStore."
            }
            Write-W2VTrace "Getting the default boot entry..."
            $defaultBootEntryId = ($bootMgr.GetElement($DEFAULT_TYPE)).Element.Id
            Write-W2VTrace "Getting the OS Loader..."
            $path    = New-Object Management.ManagementPath `
                     -ArgumentList "\\.\ROOT\WMI:BCDObject.Id=`"$($defaultBootEntryId)`",StoreFilePath=`"$($BcdStoreFile.Replace('\', '\\'))`""
            $osLoader= New-Object Management.ManagementObject -ArgumentList $scope, $path, $options
            try {
                $osLoader.Get()
            } catch {
                throw "Could not get the OS Loader..."
            }
            Write-W2VTrace "Setting Qualified Partition Device Element in the OS Loader Application..."
            $ret = $osLoader.SetQualifiedPartitionDeviceElement($APPLICATION_DEVICE_TYPE, $PartitionStyle, $DiskSignature, $PartitionOffset)
            if (!$ret.ReturnValue) {
                throw "Could not set Qualified Partition Device Element in the OS Loader Application."
            }
            Write-W2VTrace "Setting Qualified Partition Device Element in the OS Loader Device..."
            $ret = $osLoader.SetQualifiedPartitionDeviceElement($OS_DEVICE_TYPE, $PartitionStyle, $DiskSignature, $PartitionOffset)
            if (!$ret.ReturnValue) {
                throw "Could not set Qualified Partition Device Element in the OS Loader Device."
            }
            Write-W2VInfo "BCD configuration complete. Moving on..."
        }
        function Test-Admin {
            [CmdletBinding()]
            param()
            $currentUser = New-Object Security.Principal.WindowsPrincipal $([Security.Principal.WindowsIdentity]::GetCurrent())
            $isAdmin = $currentUser.IsInRole([Security.Principal.WindowsBuiltinRole]::Administrator)
            Write-W2VTrace "isUserAdmin? $isAdmin"
            return $isAdmin
        }
        function Test-WindowsVersion {
            $os = [System.Environment]::OSVersion.Version
            $isWin8 = (($os -ge 6.2) -and ($os.Build -ge $lowestSupportedBuild))
            Write-W2VTrace "is Windows 8 or Higher? $isWin8"
            return $isWin8
        }
        function Write-W2VInfo {
            [CmdletBinding()]
            param(
                [Parameter(Mandatory = $False, ValueFromPipeline = $true)]
                [string]
                [ValidateNotNullOrEmpty()]
                $text
            )

            If ($text) {
                Write-Host "INFO   : $($text)" -ForegroundColor White
            }
            Else {
                Write-Host
            }
        }
        function Write-W2VTrace {
            [CmdletBinding()]
            param(
                [Parameter(Mandatory = $true, ValueFromPipeline = $true)]
                [string]
                [ValidateNotNullOrEmpty()]
                $text
            )
            Write-Verbose $text
        }
        function Write-W2VError {
            [CmdletBinding()]
            param(
                [Parameter(Mandatory = $true, ValueFromPipeline = $true)]
                [string]
                [ValidateNotNullOrEmpty()]
                $text
            )
            Write-Host "ERROR  : $($text)" -ForegroundColor Red
        }
        function Write-W2VWarn {
            [CmdletBinding()]
            param(
                [Parameter(Mandatory = $true, ValueFromPipeline = $true)]
                [string]
                [ValidateNotNullOrEmpty()]
                $text
            )
            Write-Host "WARN   : $($text)" -ForegroundColor Yellow
        }
        function Run-Executable {
            [CmdletBinding()]
            param(
                [Parameter(Mandatory=$true)]
                [string]
                [ValidateNotNullOrEmpty()]
                $Executable,
                [Parameter(Mandatory=$true)]
                [string[]]
                [ValidateNotNullOrEmpty()]
                $Arguments,
                [Parameter()]
                [int]
                [ValidateNotNullOrEmpty()]
                $SuccessfulErrorCode = 0
            )
            Write-W2VTrace "Running $Executable $Arguments"
            $ret = Start-Process -FilePath $Executable -ArgumentList $Arguments -NoNewWindow -Wait -RedirectStandardOutput "$($env:temp)\$($scriptName)\$($sessionKey)\$($Executable)-StandardOutput.txt" -RedirectStandardError  "$($env:temp)\$($scriptName)\$($sessionKey)\$($Executable)-StandardError.txt" -Passthru
            Write-W2VTrace "Return code was $($ret.ExitCode)."
            if ($ret.ExitCode -ne $SuccessfulErrorCode) {
                throw "$Executable failed with code $($ret.ExitCode)!"
            }
        }
        Function Test-IsNetworkLocation {
            [CmdletBinding()]
            param(
                [Parameter(ValueFromPipeLine = $true)]
                [string]
                [ValidateNotNullOrEmpty()]
                $Path
            )
            $result = $false
            if ([bool]([URI]$Path).IsUNC) {
                $result = $true
            } else {
                $driveInfo = [IO.DriveInfo]((Resolve-Path $Path).Path)
                if ($driveInfo.DriveType -eq "Network") {
                    $result = $true
                }
            }
            return $result
        }
    }
    Process {
        $openWim = $null
        $openVhd = $null
        $openIso = $null
        $openImage = $null
        $vhdFinalName = $null
        $vhdFinalPath = $null
        $mountedHive = $null
        $isoPath = $null
        $vhd = @()
        Write-Host $header
        try {
            if (Test-Path $logFolder) {
                $null = rd $logFolder -Force -Recurse
            }
            $null = md $logFolder -Force
            try {
                $null = Start-Transcript -Path (Join-Path $logFolder "Convert-WindowsImageTranscript.txt") -Force -ErrorAction SilentlyContinue
                $transcripting = $true
            } catch {
                Write-W2VWarn "Transcription is already running.  No Convert-WindowsImage-specific transcript will be created."
                $transcripting = $false
            }
            Add-Type -TypeDefinition $code -ReferencedAssemblies "System.Xml","System.Linq","System.Xml.Linq"
            if (!(Test-Admin)) {
                throw "Images can only be applied by an administrator.  Please launch PowerShell elevated and run this script again."
            }
            if (!(Test-WindowsVersion)) {
                throw "$scriptName requires Windows 8 Consumer Preview or higher.  Please use WIM2VHD.WSF (http://code.msdn.microsoft.com/wim2vhd) if you need to create VHDs from Windows 7."
            }
            if (![string]::IsNullOrEmpty($UnattendPath)) {
                $UnattendPath = (Resolve-Path $UnattendPath).Path
            }
            if ("VHD" -ilike $VHDFormat) {
                if ($SizeBytes -gt $vhdMaxSize) {
                    Write-W2VWarn "For the VHD file format, the maximum file size is ~2040GB.  We're automatically setting the size to 2040GB for you."
                    $SizeBytes = 2040GB
                }
            }
            if ((![String]::IsNullOrEmpty($VHDPath)) -and (![String]::IsNullOrEmpty($WorkingDirectory))) {
                if ($WorkingDirectory -ne $pwd) {
                    Write-W2VWarn "Specifying -VHDPath and -WorkingDirectory at the same time is contradictory."
                    Write-W2VWarn "Ignoring the WorkingDirectory specification."
                    $WorkingDirectory = Split-Path $VHDPath -Parent
                }
            }
            if ($VHDPath) {
                $ext = ([IO.FileInfo]$VHDPath).Extension
                if (!($ext -ilike ".$($VHDFormat)")) {
                    throw "There is a mismatch between the VHDPath file extension ($($ext.ToUpper())), and the VHDFormat (.$($VHDFormat)).  Please ensure that these match and try again."
                }
            }
            if ([String]::IsNullOrEmpty($VHDPath)) {
                $VHDPath      = Join-Path $WorkingDirectory "$($sessionKey).$($VHDFormat.ToLower())"
            } else {
                if (![IO.Path]::IsPathRooted($VHDPath)){
                    $VHDPath  = Join-Path $WorkingDirectory $VHDPath
                }
                $vhdFinalName = Split-Path $VHDPath -Leaf
                $VHDPath      = Join-Path (Split-Path $VHDPath -Parent) "$($sessionKey).$($VHDFormat.ToLower())"
            }
            Write-W2VTrace "Temporary $VHDFormat path is : $VHDPath"
            if (([IO.FileInfo]$SourcePath).Extension -ilike ".ISO") {
                if (Test-IsNetworkLocation $SourcePath) {
                    Write-W2VInfo "Copying ISO $(Split-Path $SourcePath -Leaf) to temp folder..."
                    Copy-Item -Path $SourcePath -Destination $env:Temp -Force
                    $SourcePath = "$($env:Temp)\$(Split-Path $SourcePath -Leaf)"
                }
                $isoPath = (Resolve-Path $SourcePath).Path
                Write-W2VInfo "Opening ISO $(Split-Path $isoPath -Leaf)..."
                $openIso     = Mount-DiskImage -ImagePath $isoPath -StorageType ISO -PassThru
                $openIso     = Get-DiskImage -ImagePath $isoPath
                $driveLetter = ($openIso | Get-Volume).DriveLetter
                $SourcePath  = "$($driveLetter):\sources\install.wim"
                Write-W2VInfo "Looking for $($SourcePath)..."
                if (!(Test-Path $SourcePath)) {
                    throw "The specified ISO does not appear to be valid Windows installation media."
                }
            }
            if (Test-IsNetworkLocation $SourcePath) {
                $SourceIsNetwork = $true
                Write-W2VInfo "Copying WIM $(Split-Path $SourcePath -Leaf) to temp folder..."
                Copy-Item -Path $SourcePath -Destination $env:Temp -Force
                $SourcePath = "$($env:Temp)\$(Split-Path $SourcePath -Leaf)"
            }
            $SourcePath  = (Resolve-Path $SourcePath).Path
            $openWim     = New-Object WIM2VHD.WimFile $SourcePath
            if ($openWim.ImageNames.Contains("Windows Longhorn Client") -or $openWim.ImageNames.Contains("Windows Longhorn Server") -or $openWim.ImageNames.Contains("Windows Longhorn Server Core")) {
                throw "Convert-WindowsImage cannot run against unstaged builds. Please try again with a staged build."
            }
            if ($openWim.Images.Count -eq 1) {
                $Edition   = $openWim.Images[0].ImageFlags
                $openImage = $openWim[$Edition]
            } else {
                if ([String]::IsNullOrEmpty($Edition)) {
                    Write-W2VError "You must specify an Edition or SKU index, since the WIM has more than one image."
                    Write-W2VError "Valid edition names are:"
                    $openWim.Images | %{ Write-W2VError "  $($_.ImageFlags)" }
                    throw
                }
            }
            $Edition | ForEach-Object -Process {
                $Edition = $PSItem
                if ([Int32]::TryParse($Edition, [ref]$null)) {
                    $openImage = $openWim[[Int32]$Edition]
                } else {
                    $openImage = $openWim[$Edition]
                }
                if ($null -eq $openImage) {
                    Write-W2VError "The specified edition does not appear to exist in the specified WIM."
                    Write-W2VError "Valid edition names are:"
                    $openWim.Images | %{ Write-W2VError "  $($_.ImageFlags)" }
                    throw
                }
                Write-W2VInfo
                Write-W2VInfo "Image $($openImage.ImageIndex) selected ($($openImage.ImageFlags))..."
                if ($openImage.ImageVersion -lt $lowestSupportedVersion) {
                    throw "Convert-WindowsImage only supports Windows 7 and Windows 8 WIM files.  The specified image does not appear to contain one of those operating systems."
                }
                if ($VHDType -eq "Dynamic") {
                    Write-W2VInfo "Creating sparse disk..."
                    $openVhd = [WIM2VHD.VirtualHardDisk]::CreateSparseDisk($VHDFormat, $VHDPath, $SizeBytes, $true)
                    } else {
                        Write-W2VInfo "Creating fixed disk..."
                        $openVhd = [WIM2VHD.VirtualHardDisk]::CreateFixedDisk($VHDFormat, $VHDPath, $SizeBytes, $true)
                    }
                    Write-W2VInfo "Attaching $VHDFormat..."
                    $openVhd.Attach()
                    if ($VHDPartitionStyle -eq "MBR" ) {
                        Initialize-Disk -Number $openVhd.DiskIndex -PartitionStyle MBR
                        Write-W2VInfo "Disk initialized with MBR..."
                    } elseif ($VHDPartitionStyle -eq "GPT" ) {
                        Initialize-Disk -Number $openVhd.DiskIndex -PartitionStyle GPT
                        Write-W2VInfo "Disk initialized with GPT..."
                    }
                    $disk = Get-Disk -Number $openVhd.DiskIndex
                    if ( $VHDPartitionStyle -eq "MBR") {
                        $partition       = New-Partition -DiskNumber $openVhd.DiskIndex -Size $disk.LargestFreeExtent -MbrType IFS -IsActive
                        Write-W2VInfo "Disk partitioned..."
                    } elseif ( $VHDPartitionStyle -eq "GPT" ) {
                        Write-W2VInfo "Disk partitioned"
                        If ($BCDinVHD -eq "VirtualMachine") {
                            $PartitionSystem = New-Partition -DiskNumber $openVhd.DiskIndex -Size 100MB -GptType '{c12a7328-f81f-11d2-ba4b-00a0c93ec93b}'
                            Write-W2VInfo "System Partition created"
                        }
                        $partition = New-Partition -DiskNumber $openVhd.DiskIndex -UseMaximumSize -GptType '{ebd0a0a2-b9e5-4433-87c0-68b6b72699c7}'
                        Write-W2VInfo "Boot Partition created"
                    }
                    if ( $VHDPartitionStyle -eq "MBR" ) {
                        $volume    = Format-Volume -Partition $partition -FileSystem NTFS -Force -Confirm:$false
                        Write-W2VInfo "Volume formatted..."
                    } elseif ( $VHDPartitionStyle -eq "GPT" ) {
                        If($BCDinVHD -eq "VirtualMachine"){
                            @"
select disk $($disk.Number)
select partition $($partitionSystem.PartitionNumber)
format fs=fat32 label="System"
"@ | & $env:SystemRoot\System32\DiskPart.exe | Out-Null
                            Write-W2VInfo "System volume formatted (with DiskPart)..."
                        }
                        $volume          = Format-Volume -Partition $partition -FileSystem NTFS -Force -Confirm:$false
                        Write-W2VInfo "Boot Volume formatted (with Format-Volume)..."
                    }
                    if ( $VHDPartitionStyle -eq "MBR") {
                        $partition       | Add-PartitionAccessPath -AssignDriveLetter
                        $drive           = $(Get-Partition -Disk $disk).AccessPaths[0]
                        Write-W2VInfo "Access path ($drive) has been assigned..."
                    } elseif ( $VHDPartitionStyle -eq "GPT" ) {
                        If($BCDinVHD -eq "VirtualMachine"){
                            $partitionSystem | Add-PartitionAccessPath -AssignDriveLetter
                            $driveSystem     = $(Get-Partition -Disk $disk).AccessPaths[1]
                            Write-W2VInfo "Access path ($driveSystem) has been assigned to the System Volume..."
                            $partition       | Add-PartitionAccessPath -AssignDriveLetter
                            $drive           = $(Get-Partition -Disk $disk).AccessPaths[2]
                            Write-W2VInfo "Access path ($drive) has been assigned to the Boot Volume..."
                        }
                        ElseIf($BCDinVHD -eq "NativeBoot"){
                            $partition       | Add-PartitionAccessPath -AssignDriveLetter
                            $drive           = $(Get-Partition -Disk $disk).AccessPaths[1]
                            Write-W2VInfo "Access path ($drive) has been assigned to the Boot Volume..."
                        }
                    }
                    Write-W2VInfo "Applying image to $VHDFormat. This could take a while..."
                    $openImage.Apply($drive)
                    if (![string]::IsNullOrEmpty($UnattendPath)) {
                        Write-W2VInfo "Applying unattend file ($(Split-Path $UnattendPath -Leaf))..."
                        Copy-Item -Path $UnattendPath -Destination (Join-Path $drive "unattend.xml") -Force
                    }
                    Write-W2VInfo "Writing SetupComplete.cmd file"
                    $setup_complete = @"
del C:\unattend.xml
del C:\Windows\Panther\unattend.xml
"@
                    $setup_complete_path = Join-Path $drive "Windows\Setup\Scripts"
                    New-Item -Path $setup_complete_path -ItemType "directory"
                    $setup_complete | Out-File -FilePath (Join-Path $setup_complete_path "SetupComplete.cmd") -Encoding Unicode -Force
                    Write-W2VInfo "Signing disk..."
                    if ($openImage.ImageArchitecture -ne "ARM") {
                        if ( $BCDinVHD -eq "VirtualMachine" ) {
                            Write-W2VInfo "Image applied. Making image bootable..."
                            if ( $VHDPartitionStyle -eq "MBR" ) {
                                $bcdBootArgs = @(
                                    "$($drive)Windows",
                                    "/s $drive",
                                    "/v"
                                    "/f BIOS"
                                )
                            } elseif ( $VHDPartitionStyle -eq "GPT" ) {
                                $bcdBootArgs = @(
                                    "$($drive)Windows",
                                    "/s $driveSystem",
                                    "/v"
                                    "/f UEFI"
                                )
                            }
                            Run-Executable -Executable $BCDBoot -Arguments $bcdBootArgs
                            if ( $VHDPartitionStyle -eq "MBR" ) {
                                Write-W2VInfo "Fixing the Device ID in the BCD store on $($VHDFormat)..."
                                Run-Executable -Executable "BCDEDIT.EXE" -Arguments (
                                    "/store $($drive)boot\bcd",
                                    "/set `{bootmgr`} device locate"
                                )
                                Run-Executable -Executable "BCDEDIT.EXE" -Arguments (
                                    "/store $($drive)boot\bcd",
                                    "/set `{default`} device locate"
                                )
                                Run-Executable -Executable "BCDEDIT.EXE" -Arguments (
                                    "/store $($drive)boot\bcd",
                                    "/set `{default`} osdevice locate"
                                )
                            }
                            Write-W2VInfo "Drive is bootable. Cleaning up..."
                        } elseif ( $BCDinVHD -eq "NativeBoot" ) {
                            Write-W2VInfo "Image applied. It is not bootable without an external boot loader. Cleaning up..."
                        }
                    } else {
                        Write-W2VInfo "Not making VHD bootable, since WOA can't boot in VMs."
                    }
                    if (($RemoteDesktopEnable -eq $True) -or ($ExpandOnNativeBoot -eq $False)) {
                        $hive         = Mount-RegistryHive -Hive (Join-Path $drive "Windows\System32\Config\System")
                        if ( $RemoteDesktopEnable -eq $True ) {
                            Write-W2VInfo -text "Enabling Remote Desktop"
                            Set-ItemProperty -Path "HKLM:\$($hive)\ControlSet001\Control\Terminal Server" -Name "fDenyTSConnections" -Value 0
                        }
                        if ( $ExpandOnNativeBoot -eq $False ) {
                            Write-W2VInfo -text "Disabling automatic $VHDFormat expansion for Native Boot"
                            Set-ItemProperty -Path "HKLM:\$($hive)\ControlSet001\Services\FsDepends\Parameters" -Name "VirtualDiskExpandOnMount" -Value 4
                        }
                        Dismount-RegistryHive -HiveMountPoint $hive
                    }
                    if ( $Driver ) {
                        Write-W2VInfo -text "Adding Windows Drivers to the Image"
                        $Driver | ForEach-Object -Process {
                            Write-W2VInfo -text "Driver path: $PSItem"
                            $Dism = Add-WindowsDriver -Path $drive -Recurse -Driver $PSItem
                        }
                    }
                    If ( $Feature ) {
                        Write-W2VInfo -text "Installing Windows Feature(s) $Feature to the Image"
                        $FeatureSourcePath = Join-Path -Path "$($driveLetter):" -ChildPath "sources\sxs"
                        Write-W2VInfo -text "From $FeatureSourcePath"
                        $Dism = Enable-WindowsOptionalFeature -FeatureName $Feature -Source $FeatureSourcePath -Path $drive -All
                    }
                    if ( $Package ) {
                        Write-W2VInfo -text "Adding Windows Packages to the Image"
                        $Package | ForEach-Object -Process {
                            Write-W2VInfo -text "Package path: $PSItem"
                            $Dism = Add-WindowsPackage -Path $drive -PackagePath $PSItem
                        }
                    }
                    if ([String]::IsNullOrEmpty($vhdFinalName)) {
                        Write-W2VInfo "Generating name for $($VHDFormat)..."
                        $hive         = Mount-RegistryHive -Hive (Join-Path $drive "Windows\System32\Config\Software")
                        $buildLabEx   = (Get-ItemProperty "HKLM:\$($hive)\Microsoft\Windows NT\CurrentVersion").BuildLabEx
                        $installType  = (Get-ItemProperty "HKLM:\$($hive)\Microsoft\Windows NT\CurrentVersion").InstallationType
                        $editionId    = (Get-ItemProperty "HKLM:\$($hive)\Microsoft\Windows NT\CurrentVersion").EditionID
                        $skuFamily    = $null
                        Dismount-RegistryHive -HiveMountPoint $hive
                        if ($installType.ToUpper().Contains("CORE")) {
                            $editionId += "Core"
                        }
                        if ($installType.ToUpper().Contains("SERVER")) {
                            $skuFamily = "Server"
                        } elseif ($installType.ToUpper().Contains("CLIENT")) {
                            $skuFamily = "Client"
                        } else {
                            $skuFamily = "Unknown"
                        }
                        $vhdFinalName = "$($buildLabEx)_$($skuFamily)_$($editionId)_$($openImage.ImageDefaultLanguage).$($VHDFormat.ToLower())"
                        Write-W2VTrace "$VHDFormat final name is : $vhdFinalName"
                    }
                    $vhdFinalPathCurrent = Join-Path (Split-Path $VHDPath -Parent) $vhdFinalName
                    Write-W2VTrace "$VHDFormat final path is : $vhdFinalPathCurrent"
                    Write-W2VInfo "Closing $VHDFormat..."
                    $openVhd.Close()
                    $openVhd = $null
                    if (Test-Path $vhdFinalPathCurrent) {
                        Write-W2VInfo "Deleting pre-existing $VHDFormat : $(Split-Path $vhdFinalPathCurrent -Leaf)..."
                        Remove-Item -Path $vhdFinalPathCurrent -Force
                    }
                    $vhdFinalPath += $vhdFinalPathCurrent
                    Write-W2VTrace -Text "Renaming $VHDFormat at $VHDPath to $vhdFinalName"
                    Rename-Item -Path (Resolve-Path $VHDPath).Path -NewName $vhdFinalName -Force
                    $vhd += Get-DiskImage -ImagePath $vhdFinalPathCurrent
                    $vhdFinalName = $Null
                }
            } catch {
                Write-W2VError $_
                Write-W2VInfo "Log folder is $logFolder"
            } finally {
                if ($openWim -ne $null) {
                    Write-W2VInfo
                    Write-W2VInfo "Closing Windows image..."
                    $openWim.Close()
                }
                if ($mountedHive -ne $null) {
                    Write-W2VInfo "Closing registry hive..."
                    Dismount-RegistryHive -HiveMountPoint $mountedHive
                }
                if ($openVhd -ne $null) {
                    Write-W2VInfo "Closing $VHDFormat..."
                    $openVhd.Close()
                }
                if ($openIso -ne $null) {
                    Write-W2VInfo "Closing ISO..."
                    Dismount-DiskImage $ISOPath
                }
                if ( Test-Path -Path "Variable:\SourceIsNetwork" ) {
                    Remove-Item -Path $SourcePath
                }
                Write-W2VInfo "Done."
                if ($transcripting) {
                    $null = Stop-Transcript
                }
            }
        }
        End {
            if ($Passthru) {
                return $vhd
            }
        }
}
Export-ModuleMember -Function Convert-WindowsImage
